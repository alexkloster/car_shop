car_shop_db	information_schema	user_mapping_options	SELECT um.authorization_identifier, um.foreign_server_catalog, um.foreign_server_name, ((pg_options_to_table(um.umoptions)).option_name)::information_schema.sql_identifier AS option_name, (CASE WHEN ((((um.umuser <> (0)::oid) AND ((um.authorization_identifier)::name = "current_user"())) OR ((um.umuser = (0)::oid) AND pg_has_role((um.srvowner)::name, 'USAGE'::text))) OR (SELECT pg_authid.rolsuper FROM pg_authid WHERE (pg_authid.rolname = "current_user"()))) THEN (pg_options_to_table(um.umoptions)).option_value ELSE NULL::text END)::information_schema.character_data AS option_value FROM information_schema._pg_user_mappings um;	NONE	NO	NO
car_shop_db	information_schema	user_mappings	SELECT _pg_user_mappings.authorization_identifier, _pg_user_mappings.foreign_server_catalog, _pg_user_mappings.foreign_server_name FROM information_schema._pg_user_mappings;	NONE	NO	NO
car_shop_db	information_schema	triggered_update_columns	SELECT (current_database())::information_schema.sql_identifier AS trigger_catalog, (NULL::character varying)::information_schema.sql_identifier AS trigger_schema, (NULL::character varying)::information_schema.sql_identifier AS trigger_name, (current_database())::information_schema.sql_identifier AS event_object_catalog, (NULL::character varying)::information_schema.sql_identifier AS event_object_schema, (NULL::character varying)::information_schema.sql_identifier AS event_object_table, (NULL::character varying)::information_schema.sql_identifier AS event_object_column WHERE false;	NONE	NO	NO
car_shop_db	information_schema	triggers	SELECT (current_database())::information_schema.sql_identifier AS trigger_catalog, (n.nspname)::information_schema.sql_identifier AS trigger_schema, (t.tgname)::information_schema.sql_identifier AS trigger_name, (em.text)::information_schema.character_data AS event_manipulation, (current_database())::information_schema.sql_identifier AS event_object_catalog, (n.nspname)::information_schema.sql_identifier AS event_object_schema, (c.relname)::information_schema.sql_identifier AS event_object_table, (NULL::integer)::information_schema.cardinal_number AS action_order, (NULL::character varying)::information_schema.character_data AS action_condition, ("substring"(pg_get_triggerdef(t.oid), ("position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE'::text) + 47)))::information_schema.character_data AS action_statement, (CASE WHEN (((t.tgtype)::integer & 1) = 1) THEN 'ROW'::text ELSE 'STATEMENT'::text END)::information_schema.character_data AS action_orientation, (CASE WHEN (((t.tgtype)::integer & 2) = 2) THEN 'BEFORE'::text ELSE 'AFTER'::text END)::information_schema.character_data AS condition_timing, (NULL::character varying)::information_schema.sql_identifier AS condition_reference_old_table, (NULL::character varying)::information_schema.sql_identifier AS condition_reference_new_table, (NULL::character varying)::information_schema.sql_identifier AS condition_reference_old_row, (NULL::character varying)::information_schema.sql_identifier AS condition_reference_new_row, (NULL::timestamp with time zone)::information_schema.time_stamp AS created FROM pg_namespace n, pg_class c, pg_trigger t, (VALUES (4,'INSERT'::text), (8,'DELETE'::text), (16,'UPDATE'::text)) em(num, text) WHERE ((((((n.oid = c.relnamespace) AND (c.oid = t.tgrelid)) AND (((t.tgtype)::integer & em.num) <> 0)) AND (NOT t.tgisconstraint)) AND (NOT pg_is_other_temp_schema(n.oid))) AND ((pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text)));	NONE	NO	NO
car_shop_db	information_schema	usage_privileges	(SELECT (u.rolname)::information_schema.sql_identifier AS grantor, ('PUBLIC'::character varying)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS object_catalog, (n.nspname)::information_schema.sql_identifier AS object_schema, (t.typname)::information_schema.sql_identifier AS object_name, ('DOMAIN'::character varying)::information_schema.character_data AS object_type, ('USAGE'::character varying)::information_schema.character_data AS privilege_type, ('NO'::character varying)::information_schema.character_data AS is_grantable FROM pg_authid u, pg_namespace n, pg_type t WHERE (((u.oid = t.typowner) AND (t.typnamespace = n.oid)) AND (t.typtype = 'd'::"char")) UNION ALL SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS object_catalog, (''::character varying)::information_schema.sql_identifier AS object_schema, (fdw.fdwname)::information_schema.sql_identifier AS object_name, ('FOREIGN DATA WRAPPER'::character varying)::information_schema.character_data AS object_type, ('USAGE'::character varying)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE'::text) OR aclcontains(fdw.fdwacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE'::text, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_foreign_data_wrapper fdw, pg_authid u_grantor, (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid UNION ALL SELECT (0)::oid AS oid, 'PUBLIC') grantee(oid, rolname) WHERE (aclcontains(fdw.fdwacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE'::text, false)) AND ((pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text)) OR (grantee.rolname = 'PUBLIC'::name)))) UNION ALL SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS object_catalog, (''::character varying)::information_schema.sql_identifier AS object_schema, (srv.srvname)::information_schema.sql_identifier AS object_name, ('FOREIGN SERVER'::character varying)::information_schema.character_data AS object_type, ('USAGE'::character varying)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(grantee.oid, srv.srvowner, 'USAGE'::text) OR aclcontains(srv.srvacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE'::text, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_foreign_server srv, pg_authid u_grantor, (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid UNION ALL SELECT (0)::oid AS oid, 'PUBLIC') grantee(oid, rolname) WHERE (aclcontains(srv.srvacl, makeaclitem(grantee.oid, u_grantor.oid, 'USAGE'::text, false)) AND ((pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text)) OR (grantee.rolname = 'PUBLIC'::name)));	NONE	NO	NO
car_shop_db	information_schema	view_column_usage	SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog, (nv.nspname)::information_schema.sql_identifier AS view_schema, (v.relname)::information_schema.sql_identifier AS view_name, (current_database())::information_schema.sql_identifier AS table_catalog, (nt.nspname)::information_schema.sql_identifier AS table_schema, (t.relname)::information_schema.sql_identifier AS table_name, (a.attname)::information_schema.sql_identifier AS column_name FROM pg_namespace nv, pg_class v, pg_depend dv, pg_depend dt, pg_class t, pg_namespace nt, pg_attribute a WHERE ((((((((((((((((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char")) AND (v.oid = dv.refobjid)) AND (dv.refclassid = ('pg_class'::regclass)::oid)) AND (dv.classid = ('pg_rewrite'::regclass)::oid)) AND (dv.deptype = 'i'::"char")) AND (dv.objid = dt.objid)) AND (dv.refobjid <> dt.refobjid)) AND (dt.classid = ('pg_rewrite'::regclass)::oid)) AND (dt.refclassid = ('pg_class'::regclass)::oid)) AND (dt.refobjid = t.oid)) AND (t.relnamespace = nt.oid)) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND (t.oid = a.attrelid)) AND (dt.refobjsubid = a.attnum)) AND pg_has_role(t.relowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	information_schema	view_routine_usage	SELECT DISTINCT (current_database())::information_schema.sql_identifier AS table_catalog, (nv.nspname)::information_schema.sql_identifier AS table_schema, (v.relname)::information_schema.sql_identifier AS table_name, (current_database())::information_schema.sql_identifier AS specific_catalog, (np.nspname)::information_schema.sql_identifier AS specific_schema, ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name FROM pg_namespace nv, pg_class v, pg_depend dv, pg_depend dp, pg_proc p, pg_namespace np WHERE ((((((((((((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char")) AND (v.oid = dv.refobjid)) AND (dv.refclassid = ('pg_class'::regclass)::oid)) AND (dv.classid = ('pg_rewrite'::regclass)::oid)) AND (dv.deptype = 'i'::"char")) AND (dv.objid = dp.objid)) AND (dp.classid = ('pg_rewrite'::regclass)::oid)) AND (dp.refclassid = ('pg_proc'::regclass)::oid)) AND (dp.refobjid = p.oid)) AND (p.pronamespace = np.oid)) AND pg_has_role(p.proowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	information_schema	view_table_usage	SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog, (nv.nspname)::information_schema.sql_identifier AS view_schema, (v.relname)::information_schema.sql_identifier AS view_name, (current_database())::information_schema.sql_identifier AS table_catalog, (nt.nspname)::information_schema.sql_identifier AS table_schema, (t.relname)::information_schema.sql_identifier AS table_name FROM pg_namespace nv, pg_class v, pg_depend dv, pg_depend dt, pg_class t, pg_namespace nt WHERE ((((((((((((((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char")) AND (v.oid = dv.refobjid)) AND (dv.refclassid = ('pg_class'::regclass)::oid)) AND (dv.classid = ('pg_rewrite'::regclass)::oid)) AND (dv.deptype = 'i'::"char")) AND (dv.objid = dt.objid)) AND (dv.refobjid <> dt.refobjid)) AND (dt.classid = ('pg_rewrite'::regclass)::oid)) AND (dt.refclassid = ('pg_class'::regclass)::oid)) AND (dt.refobjid = t.oid)) AND (t.relnamespace = nt.oid)) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND pg_has_role(t.relowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	information_schema	views	SELECT (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (CASE WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN pg_get_viewdef(c.oid) ELSE NULL::text END)::information_schema.character_data AS view_definition, ('NONE'::character varying)::information_schema.character_data AS check_option, (CASE WHEN ((EXISTS (SELECT 1 FROM pg_rewrite WHERE (((pg_rewrite.ev_class = c.oid) AND (pg_rewrite.ev_type = '2'::"char")) AND pg_rewrite.is_instead))) AND (EXISTS (SELECT 1 FROM pg_rewrite WHERE (((pg_rewrite.ev_class = c.oid) AND (pg_rewrite.ev_type = '4'::"char")) AND pg_rewrite.is_instead)))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_updatable, (CASE WHEN (EXISTS (SELECT 1 FROM pg_rewrite WHERE (((pg_rewrite.ev_class = c.oid) AND (pg_rewrite.ev_type = '3'::"char")) AND pg_rewrite.is_instead))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_insertable_into FROM pg_namespace nc, pg_class c WHERE ((((c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char")) AND (NOT pg_is_other_temp_schema(nc.oid))) AND ((pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));	NONE	NO	NO
car_shop_db	information_schema	data_type_privileges	SELECT (current_database())::information_schema.sql_identifier AS object_catalog, x.objschema AS object_schema, x.objname AS object_name, (x.objtype)::information_schema.character_data AS object_type, x.objdtdid AS dtd_identifier FROM ((((SELECT attributes.udt_schema, attributes.udt_name, 'USER-DEFINED TYPE'::text AS text, attributes.dtd_identifier FROM information_schema.attributes UNION ALL SELECT columns.table_schema, columns.table_name, 'TABLE'::text AS text, columns.dtd_identifier FROM information_schema.columns) UNION ALL SELECT domains.domain_schema, domains.domain_name, 'DOMAIN'::text AS text, domains.dtd_identifier FROM information_schema.domains) UNION ALL SELECT parameters.specific_schema, parameters.specific_name, 'ROUTINE'::text AS text, parameters.dtd_identifier FROM information_schema.parameters) UNION ALL SELECT routines.specific_schema, routines.specific_name, 'ROUTINE'::text AS text, routines.dtd_identifier FROM information_schema.routines) x(objschema, objname, objtype, objdtdid);	NONE	NO	NO
car_shop_db	information_schema	element_types	SELECT (current_database())::information_schema.sql_identifier AS object_catalog, (n.nspname)::information_schema.sql_identifier AS object_schema, x.objname AS object_name, (x.objtype)::information_schema.character_data AS object_type, (x.objdtdid)::information_schema.sql_identifier AS collection_type_identifier, (CASE WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(bt.oid, NULL::integer) ELSE 'USER-DEFINED'::text END)::information_schema.character_data AS data_type, (NULL::integer)::information_schema.cardinal_number AS character_maximum_length, (NULL::integer)::information_schema.cardinal_number AS character_octet_length, (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS character_set_schema, (NULL::character varying)::information_schema.sql_identifier AS character_set_name, (NULL::character varying)::information_schema.sql_identifier AS collation_catalog, (NULL::character varying)::information_schema.sql_identifier AS collation_schema, (NULL::character varying)::information_schema.sql_identifier AS collation_name, (NULL::integer)::information_schema.cardinal_number AS numeric_precision, (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix, (NULL::integer)::information_schema.cardinal_number AS numeric_scale, (NULL::integer)::information_schema.cardinal_number AS datetime_precision, (NULL::character varying)::information_schema.character_data AS interval_type, (NULL::character varying)::information_schema.character_data AS interval_precision, (NULL::character varying)::information_schema.character_data AS domain_default, (current_database())::information_schema.sql_identifier AS udt_catalog, (nbt.nspname)::information_schema.sql_identifier AS udt_schema, (bt.typname)::information_schema.sql_identifier AS udt_name, (NULL::character varying)::information_schema.sql_identifier AS scope_catalog, (NULL::character varying)::information_schema.sql_identifier AS scope_schema, (NULL::character varying)::information_schema.sql_identifier AS scope_name, (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality, (('a'::text || (x.objdtdid)::text))::information_schema.sql_identifier AS dtd_identifier FROM pg_namespace n, pg_type at, pg_namespace nbt, pg_type bt, (((SELECT c.relnamespace, (c.relname)::information_schema.sql_identifier AS relname, 'TABLE'::text AS text, a.attnum, a.atttypid FROM pg_class c, pg_attribute a WHERE ((((c.oid = a.attrelid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND (a.attnum > 0)) AND (NOT a.attisdropped)) UNION ALL SELECT t.typnamespace, (t.typname)::information_schema.sql_identifier AS typname, 'DOMAIN'::text AS text, 1, t.typbasetype FROM pg_type t WHERE (t.typtype = 'd'::"char")) UNION ALL SELECT ss.pronamespace, ((((ss.proname)::text || '_'::text) || (ss.oid)::text))::information_schema.sql_identifier AS sql_identifier, 'ROUTINE'::text AS text, (ss.x).n AS n, (ss.x).x AS x FROM (SELECT p.pronamespace, p.proname, p.oid, information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x FROM pg_proc p) ss) UNION ALL SELECT p.pronamespace, ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS sql_identifier, 'ROUTINE'::text AS text, 0, p.prorettype FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid) WHERE ((((((n.oid = x.objschema) AND (at.oid = x.objtypeid)) AND ((at.typelem <> (0)::oid) AND (at.typlen = (-1)))) AND (at.typelem = bt.oid)) AND (nbt.oid = bt.typnamespace)) AND ((n.nspname, (x.objname)::text, x.objtype, ((x.objdtdid)::information_schema.sql_identifier)::text) IN (SELECT data_type_privileges.object_schema, data_type_privileges.object_name, data_type_privileges.object_type, data_type_privileges.dtd_identifier FROM information_schema.data_type_privileges)));	NONE	NO	NO
car_shop_db	information_schema	_pg_foreign_data_wrappers	SELECT w.oid, w.fdwowner, w.fdwoptions, (current_database())::information_schema.sql_identifier AS foreign_data_wrapper_catalog, (w.fdwname)::information_schema.sql_identifier AS foreign_data_wrapper_name, (u.rolname)::information_schema.sql_identifier AS authorization_identifier, ('c'::character varying)::information_schema.character_data AS foreign_data_wrapper_language FROM pg_foreign_data_wrapper w, pg_authid u WHERE ((u.oid = w.fdwowner) AND (pg_has_role(w.fdwowner, 'USAGE'::text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'::text)));	NONE	NO	NO
car_shop_db	information_schema	foreign_data_wrapper_options	SELECT w.foreign_data_wrapper_catalog, w.foreign_data_wrapper_name, ((pg_options_to_table(w.fdwoptions)).option_name)::information_schema.sql_identifier AS option_name, ((pg_options_to_table(w.fdwoptions)).option_value)::information_schema.character_data AS option_value FROM information_schema._pg_foreign_data_wrappers w;	NONE	NO	NO
car_shop_db	information_schema	foreign_data_wrappers	SELECT w.foreign_data_wrapper_catalog, w.foreign_data_wrapper_name, w.authorization_identifier, (NULL::character varying)::information_schema.character_data AS library_name, w.foreign_data_wrapper_language FROM information_schema._pg_foreign_data_wrappers w;	NONE	NO	NO
car_shop_db	information_schema	_pg_foreign_servers	SELECT s.oid, s.srvoptions, (current_database())::information_schema.sql_identifier AS foreign_server_catalog, (s.srvname)::information_schema.sql_identifier AS foreign_server_name, (current_database())::information_schema.sql_identifier AS foreign_data_wrapper_catalog, (w.fdwname)::information_schema.sql_identifier AS foreign_data_wrapper_name, (s.srvtype)::information_schema.character_data AS foreign_server_type, (s.srvversion)::information_schema.character_data AS foreign_server_version, (u.rolname)::information_schema.sql_identifier AS authorization_identifier FROM pg_foreign_server s, pg_foreign_data_wrapper w, pg_authid u WHERE (((w.oid = s.srvfdw) AND (u.oid = s.srvowner)) AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)));	NONE	NO	NO
car_shop_db	information_schema	foreign_server_options	SELECT s.foreign_server_catalog, s.foreign_server_name, ((pg_options_to_table(s.srvoptions)).option_name)::information_schema.sql_identifier AS option_name, ((pg_options_to_table(s.srvoptions)).option_value)::information_schema.character_data AS option_value FROM information_schema._pg_foreign_servers s;	NONE	NO	NO
car_shop_db	information_schema	foreign_servers	SELECT _pg_foreign_servers.foreign_server_catalog, _pg_foreign_servers.foreign_server_name, _pg_foreign_servers.foreign_data_wrapper_catalog, _pg_foreign_servers.foreign_data_wrapper_name, _pg_foreign_servers.foreign_server_type, _pg_foreign_servers.foreign_server_version, _pg_foreign_servers.authorization_identifier FROM information_schema._pg_foreign_servers;	NONE	NO	NO
car_shop_db	information_schema	_pg_user_mappings	SELECT um.oid, um.umoptions, um.umuser, (COALESCE(u.rolname, 'PUBLIC'::name))::information_schema.sql_identifier AS authorization_identifier, s.foreign_server_catalog, s.foreign_server_name, s.authorization_identifier AS srvowner FROM (pg_user_mapping um LEFT JOIN pg_authid u ON ((u.oid = um.umuser))), information_schema._pg_foreign_servers s WHERE (s.oid = um.umserver);	NONE	NO	NO
car_shop_db	information_schema	sequences	SELECT (current_database())::information_schema.sql_identifier AS sequence_catalog, (nc.nspname)::information_schema.sql_identifier AS sequence_schema, (c.relname)::information_schema.sql_identifier AS sequence_name, ('bigint'::character varying)::information_schema.character_data AS data_type, (64)::information_schema.cardinal_number AS numeric_precision, (2)::information_schema.cardinal_number AS numeric_precision_radix, (0)::information_schema.cardinal_number AS numeric_scale, (NULL::integer)::information_schema.cardinal_number AS maximum_value, (NULL::integer)::information_schema.cardinal_number AS minimum_value, (NULL::integer)::information_schema.cardinal_number AS increment, (NULL::character varying)::information_schema.character_data AS cycle_option FROM pg_namespace nc, pg_class c WHERE ((((c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char")) AND (NOT pg_is_other_temp_schema(nc.oid))) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, UPDATE'::text)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_roles	SELECT pg_authid.rolname, pg_authid.rolsuper, pg_authid.rolinherit, pg_authid.rolcreaterole, pg_authid.rolcreatedb, pg_authid.rolcatupdate, pg_authid.rolcanlogin, pg_authid.rolconnlimit, '********'::text AS rolpassword, pg_authid.rolvaliduntil, pg_authid.rolconfig, pg_authid.oid FROM pg_authid;	NONE	NO	NO
car_shop_db	pg_catalog	pg_shadow	SELECT pg_authid.rolname AS usename, pg_authid.oid AS usesysid, pg_authid.rolcreatedb AS usecreatedb, pg_authid.rolsuper AS usesuper, pg_authid.rolcatupdate AS usecatupd, pg_authid.rolpassword AS passwd, (pg_authid.rolvaliduntil)::abstime AS valuntil, pg_authid.rolconfig AS useconfig FROM pg_authid WHERE pg_authid.rolcanlogin;	NONE	NO	NO
car_shop_db	pg_catalog	pg_group	SELECT pg_authid.rolname AS groname, pg_authid.oid AS grosysid, ARRAY(SELECT pg_auth_members.member FROM pg_auth_members WHERE (pg_auth_members.roleid = pg_authid.oid)) AS grolist FROM pg_authid WHERE (NOT pg_authid.rolcanlogin);	NONE	NO	NO
car_shop_db	pg_catalog	pg_user	SELECT pg_shadow.usename, pg_shadow.usesysid, pg_shadow.usecreatedb, pg_shadow.usesuper, pg_shadow.usecatupd, '********'::text AS passwd, pg_shadow.valuntil, pg_shadow.useconfig FROM pg_shadow;	NONE	NO	NO
car_shop_db	pg_catalog	pg_rules	SELECT n.nspname AS schemaname, c.relname AS tablename, r.rulename, pg_get_ruledef(r.oid) AS definition FROM ((pg_rewrite r JOIN pg_class c ON ((c.oid = r.ev_class))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (r.rulename <> '_RETURN'::name);	NONE	NO	NO
car_shop_db	pg_catalog	pg_views	SELECT n.nspname AS schemaname, c.relname AS viewname, pg_get_userbyid(c.relowner) AS viewowner, pg_get_viewdef(c.oid) AS definition FROM (pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'v'::"char");	NONE	NO	NO
car_shop_db	pg_catalog	pg_tables	SELECT n.nspname AS schemaname, c.relname AS tablename, pg_get_userbyid(c.relowner) AS tableowner, t.spcname AS tablespace, c.relhasindex AS hasindexes, c.relhasrules AS hasrules, c.relhastriggers AS hastriggers FROM ((pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace))) WHERE (c.relkind = 'r'::"char");	NONE	NO	NO
car_shop_db	pg_catalog	pg_indexes	SELECT n.nspname AS schemaname, c.relname AS tablename, i.relname AS indexname, t.spcname AS tablespace, pg_get_indexdef(i.oid) AS indexdef FROM ((((pg_index x JOIN pg_class c ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace))) WHERE ((c.relkind = 'r'::"char") AND (i.relkind = 'i'::"char"));	NONE	NO	NO
car_shop_db	information_schema	table_constraints	SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (nc.nspname)::information_schema.sql_identifier AS constraint_schema, (c.conname)::information_schema.sql_identifier AS constraint_name, (current_database())::information_schema.sql_identifier AS table_catalog, (nr.nspname)::information_schema.sql_identifier AS table_schema, (r.relname)::information_schema.sql_identifier AS table_name, (CASE c.contype WHEN 'c'::"char" THEN 'CHECK'::text WHEN 'f'::"char" THEN 'FOREIGN KEY'::text WHEN 'p'::"char" THEN 'PRIMARY KEY'::text WHEN 'u'::"char" THEN 'UNIQUE'::text ELSE NULL::text END)::information_schema.character_data AS constraint_type, (CASE WHEN c.condeferrable THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_deferrable, (CASE WHEN c.condeferred THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS initially_deferred FROM pg_namespace nc, pg_namespace nr, pg_constraint c, pg_class r WHERE ((((((nc.oid = c.connamespace) AND (nr.oid = r.relnamespace)) AND (c.conrelid = r.oid)) AND (r.relkind = 'r'::"char")) AND (NOT pg_is_other_temp_schema(nr.oid))) AND ((pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text))) UNION ALL SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (nr.nspname)::information_schema.sql_identifier AS constraint_schema, (((((((nr.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) || '_not_null'::text))::information_schema.sql_identifier AS constraint_name, (current_database())::information_schema.sql_identifier AS table_catalog, (nr.nspname)::information_schema.sql_identifier AS table_schema, (r.relname)::information_schema.sql_identifier AS table_name, ('CHECK'::character varying)::information_schema.character_data AS constraint_type, ('NO'::character varying)::information_schema.character_data AS is_deferrable, ('NO'::character varying)::information_schema.character_data AS initially_deferred FROM pg_namespace nr, pg_class r, pg_attribute a WHERE ((((((((nr.oid = r.relnamespace) AND (r.oid = a.attrelid)) AND a.attnotnull) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND (r.relkind = 'r'::"char")) AND (NOT pg_is_other_temp_schema(nr.oid))) AND ((pg_has_role(r.relowner, 'USAGE'::text) OR has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) OR has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stats	SELECT n.nspname AS schemaname, c.relname AS tablename, a.attname, s.stanullfrac AS null_frac, s.stawidth AS avg_width, s.stadistinct AS n_distinct, CASE WHEN (s.stakind1 = ANY (ARRAY[1, 4])) THEN s.stavalues1 WHEN (s.stakind2 = ANY (ARRAY[1, 4])) THEN s.stavalues2 WHEN (s.stakind3 = ANY (ARRAY[1, 4])) THEN s.stavalues3 WHEN (s.stakind4 = ANY (ARRAY[1, 4])) THEN s.stavalues4 ELSE NULL::anyarray END AS most_common_vals, CASE WHEN (s.stakind1 = ANY (ARRAY[1, 4])) THEN s.stanumbers1 WHEN (s.stakind2 = ANY (ARRAY[1, 4])) THEN s.stanumbers2 WHEN (s.stakind3 = ANY (ARRAY[1, 4])) THEN s.stanumbers3 WHEN (s.stakind4 = ANY (ARRAY[1, 4])) THEN s.stanumbers4 ELSE NULL::real[] END AS most_common_freqs, CASE WHEN (s.stakind1 = 2) THEN s.stavalues1 WHEN (s.stakind2 = 2) THEN s.stavalues2 WHEN (s.stakind3 = 2) THEN s.stavalues3 WHEN (s.stakind4 = 2) THEN s.stavalues4 ELSE NULL::anyarray END AS histogram_bounds, CASE WHEN (s.stakind1 = 3) THEN s.stanumbers1[1] WHEN (s.stakind2 = 3) THEN s.stanumbers2[1] WHEN (s.stakind3 = 3) THEN s.stanumbers3[1] WHEN (s.stakind4 = 3) THEN s.stanumbers4[1] ELSE NULL::real END AS correlation FROM (((pg_statistic s JOIN pg_class c ON ((c.oid = s.starelid))) JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum)))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text));	NONE	NO	NO
car_shop_db	information_schema	table_privileges	SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (pr.type)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR aclcontains(c.relacl, makeaclitem(grantee.oid, u_grantor.oid, pr.type, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable, ('NO'::character varying)::information_schema.character_data AS with_hierarchy FROM pg_class c, pg_namespace nc, pg_authid u_grantor, (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid UNION ALL SELECT (0)::oid AS oid, 'PUBLIC') grantee(oid, rolname), (VALUES ('SELECT'::text), ('INSERT'::text), ('UPDATE'::text), ('DELETE'::text), ('TRUNCATE'::text), ('REFERENCES'::text), ('TRIGGER'::text)) pr(type) WHERE ((((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND aclcontains(c.relacl, makeaclitem(grantee.oid, u_grantor.oid, pr.type, false))) AND ((pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text)) OR (grantee.rolname = 'PUBLIC'::name)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_locks	SELECT l.locktype, l.database, l.relation, l.page, l.tuple, l.virtualxid, l.transactionid, l.classid, l.objid, l.objsubid, l.virtualtransaction, l.pid, l.mode, l.granted FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted);	NONE	NO	NO
car_shop_db	information_schema	tables	SELECT (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (CASE WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY'::text WHEN (c.relkind = 'r'::"char") THEN 'BASE TABLE'::text WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text ELSE NULL::text END)::information_schema.character_data AS table_type, (NULL::character varying)::information_schema.sql_identifier AS self_referencing_column_name, (NULL::character varying)::information_schema.character_data AS reference_generation, (NULL::character varying)::information_schema.sql_identifier AS user_defined_type_catalog, (NULL::character varying)::information_schema.sql_identifier AS user_defined_type_schema, (NULL::character varying)::information_schema.sql_identifier AS user_defined_type_name, (CASE WHEN ((c.relkind = 'r'::"char") OR ((c.relkind = 'v'::"char") AND (EXISTS (SELECT 1 FROM pg_rewrite WHERE (((pg_rewrite.ev_class = c.oid) AND (pg_rewrite.ev_type = '3'::"char")) AND pg_rewrite.is_instead))))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_insertable_into, ('NO'::character varying)::information_schema.character_data AS is_typed, (CASE WHEN (nc.oid = pg_my_temp_schema()) THEN 'PRESERVE'::text ELSE NULL::text END)::information_schema.character_data AS commit_action FROM pg_namespace nc, pg_class c WHERE ((((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND (NOT pg_is_other_temp_schema(nc.oid))) AND ((pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_cursors	SELECT c.name, c.statement, c.is_holdable, c.is_binary, c.is_scrollable, c.creation_time FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);	NONE	NO	NO
car_shop_db	information_schema	constraint_table_usage	SELECT (current_database())::information_schema.sql_identifier AS table_catalog, (nr.nspname)::information_schema.sql_identifier AS table_schema, (r.relname)::information_schema.sql_identifier AS table_name, (current_database())::information_schema.sql_identifier AS constraint_catalog, (nc.nspname)::information_schema.sql_identifier AS constraint_schema, (c.conname)::information_schema.sql_identifier AS constraint_name FROM pg_constraint c, pg_namespace nc, pg_class r, pg_namespace nr WHERE (((((c.connamespace = nc.oid) AND (r.relnamespace = nr.oid)) AND (((c.contype = 'f'::"char") AND (c.confrelid = r.oid)) OR ((c.contype = ANY (ARRAY['p'::"char", 'u'::"char"])) AND (c.conrelid = r.oid)))) AND (r.relkind = 'r'::"char")) AND pg_has_role(r.relowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_prepared_xacts	SELECT p.transaction, p.gid, p.prepared, u.rolname AS owner, d.datname AS database FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid) LEFT JOIN pg_authid u ON ((p.ownerid = u.oid))) LEFT JOIN pg_database d ON ((p.dbid = d.oid)));	NONE	NO	NO
car_shop_db	information_schema	domain_constraints	SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (rs.nspname)::information_schema.sql_identifier AS constraint_schema, (con.conname)::information_schema.sql_identifier AS constraint_name, (current_database())::information_schema.sql_identifier AS domain_catalog, (n.nspname)::information_schema.sql_identifier AS domain_schema, (t.typname)::information_schema.sql_identifier AS domain_name, (CASE WHEN con.condeferrable THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_deferrable, (CASE WHEN con.condeferred THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS initially_deferred FROM pg_namespace rs, pg_namespace n, pg_constraint con, pg_type t WHERE (((rs.oid = con.connamespace) AND (n.oid = t.typnamespace)) AND (t.oid = con.contypid));	NONE	NO	NO
car_shop_db	pg_catalog	pg_prepared_statements	SELECT p.name, p.statement, p.prepare_time, p.parameter_types, p.from_sql FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);	NONE	NO	NO
car_shop_db	information_schema	domain_udt_usage	SELECT (current_database())::information_schema.sql_identifier AS udt_catalog, (nbt.nspname)::information_schema.sql_identifier AS udt_schema, (bt.typname)::information_schema.sql_identifier AS udt_name, (current_database())::information_schema.sql_identifier AS domain_catalog, (nt.nspname)::information_schema.sql_identifier AS domain_schema, (t.typname)::information_schema.sql_identifier AS domain_name FROM pg_type t, pg_namespace nt, pg_type bt, pg_namespace nbt WHERE (((((t.typnamespace = nt.oid) AND (t.typbasetype = bt.oid)) AND (bt.typnamespace = nbt.oid)) AND (t.typtype = 'd'::"char")) AND pg_has_role(bt.typowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_settings	SELECT a.name, a.setting, a.unit, a.category, a.short_desc, a.extra_desc, a.context, a.vartype, a.source, a.min_val, a.max_val, a.enumvals, a.boot_val, a.reset_val, a.sourcefile, a.sourceline FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline);	NONE	NO	NO
car_shop_db	information_schema	domains	SELECT (current_database())::information_schema.sql_identifier AS domain_catalog, (nt.nspname)::information_schema.sql_identifier AS domain_schema, (t.typname)::information_schema.sql_identifier AS domain_name, (CASE WHEN ((t.typelem <> (0)::oid) AND (t.typlen = (-1))) THEN 'ARRAY'::text WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer) ELSE 'USER-DEFINED'::text END)::information_schema.character_data AS data_type, (information_schema._pg_char_max_length(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS character_maximum_length, (information_schema._pg_char_octet_length(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS character_octet_length, (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS character_set_schema, (NULL::character varying)::information_schema.sql_identifier AS character_set_name, (NULL::character varying)::information_schema.sql_identifier AS collation_catalog, (NULL::character varying)::information_schema.sql_identifier AS collation_schema, (NULL::character varying)::information_schema.sql_identifier AS collation_name, (information_schema._pg_numeric_precision(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_precision, (information_schema._pg_numeric_precision_radix(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_precision_radix, (information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS numeric_scale, (information_schema._pg_datetime_precision(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS datetime_precision, (NULL::character varying)::information_schema.character_data AS interval_type, (NULL::character varying)::information_schema.character_data AS interval_precision, (t.typdefault)::information_schema.character_data AS domain_default, (current_database())::information_schema.sql_identifier AS udt_catalog, (nbt.nspname)::information_schema.sql_identifier AS udt_schema, (bt.typname)::information_schema.sql_identifier AS udt_name, (NULL::character varying)::information_schema.sql_identifier AS scope_catalog, (NULL::character varying)::information_schema.sql_identifier AS scope_schema, (NULL::character varying)::information_schema.sql_identifier AS scope_name, (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality, (1)::information_schema.sql_identifier AS dtd_identifier FROM pg_type t, pg_namespace nt, pg_type bt, pg_namespace nbt WHERE ((((t.typnamespace = nt.oid) AND (t.typbasetype = bt.oid)) AND (bt.typnamespace = nbt.oid)) AND (t.typtype = 'd'::"char"));	NONE	NO	NO
car_shop_db	information_schema	enabled_roles	SELECT (a.rolname)::information_schema.sql_identifier AS role_name FROM pg_authid a WHERE pg_has_role(a.oid, 'USAGE'::text);	NONE	NO	NO
car_shop_db	pg_catalog	pg_timezone_abbrevs	SELECT pg_timezone_abbrevs.abbrev, pg_timezone_abbrevs.utc_offset, pg_timezone_abbrevs.is_dst FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);	NONE	NO	NO
car_shop_db	information_schema	key_column_usage	SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (ss.nc_nspname)::information_schema.sql_identifier AS constraint_schema, (ss.conname)::information_schema.sql_identifier AS constraint_name, (current_database())::information_schema.sql_identifier AS table_catalog, (ss.nr_nspname)::information_schema.sql_identifier AS table_schema, (ss.relname)::information_schema.sql_identifier AS table_name, (a.attname)::information_schema.sql_identifier AS column_name, ((ss.x).n)::information_schema.cardinal_number AS ordinal_position, (CASE WHEN (ss.contype = 'f'::"char") THEN information_schema._pg_index_position(information_schema._pg_underlying_index(ss.coid), ss.confkey[(ss.x).n]) ELSE NULL::integer END)::information_schema.cardinal_number AS position_in_unique_constraint FROM pg_attribute a, (SELECT r.oid AS roid, r.relname, r.relowner, nc.nspname AS nc_nspname, nr.nspname AS nr_nspname, c.oid AS coid, c.conname, c.contype, c.confkey, c.confrelid, information_schema._pg_expandarray(c.conkey) AS x FROM pg_namespace nr, pg_class r, pg_namespace nc, pg_constraint c WHERE ((((((nr.oid = r.relnamespace) AND (r.oid = c.conrelid)) AND (nc.oid = c.connamespace)) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"]))) AND (r.relkind = 'r'::"char")) AND (NOT pg_is_other_temp_schema(nr.oid)))) ss WHERE ((((ss.roid = a.attrelid) AND (a.attnum = (ss.x).x)) AND (NOT a.attisdropped)) AND (pg_has_role(ss.relowner, 'USAGE'::text) OR has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_timezone_names	SELECT pg_timezone_names.name, pg_timezone_names.abbrev, pg_timezone_names.utc_offset, pg_timezone_names.is_dst FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);	NONE	NO	NO
car_shop_db	information_schema	parameters	SELECT (current_database())::information_schema.sql_identifier AS specific_catalog, (ss.n_nspname)::information_schema.sql_identifier AS specific_schema, ((((ss.proname)::text || '_'::text) || (ss.p_oid)::text))::information_schema.sql_identifier AS specific_name, ((ss.x).n)::information_schema.cardinal_number AS ordinal_position, (CASE WHEN (ss.proargmodes IS NULL) THEN 'IN'::text WHEN (ss.proargmodes[(ss.x).n] = 'i'::"char") THEN 'IN'::text WHEN (ss.proargmodes[(ss.x).n] = 'o'::"char") THEN 'OUT'::text WHEN (ss.proargmodes[(ss.x).n] = 'b'::"char") THEN 'INOUT'::text WHEN (ss.proargmodes[(ss.x).n] = 'v'::"char") THEN 'IN'::text WHEN (ss.proargmodes[(ss.x).n] = 't'::"char") THEN 'OUT'::text ELSE NULL::text END)::information_schema.character_data AS parameter_mode, ('NO'::character varying)::information_schema.character_data AS is_result, ('NO'::character varying)::information_schema.character_data AS as_locator, (NULLIF(ss.proargnames[(ss.x).n], ''::text))::information_schema.sql_identifier AS parameter_name, (CASE WHEN ((t.typelem <> (0)::oid) AND (t.typlen = (-1))) THEN 'ARRAY'::text WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer) ELSE 'USER-DEFINED'::text END)::information_schema.character_data AS data_type, (NULL::integer)::information_schema.cardinal_number AS character_maximum_length, (NULL::integer)::information_schema.cardinal_number AS character_octet_length, (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS character_set_schema, (NULL::character varying)::information_schema.sql_identifier AS character_set_name, (NULL::character varying)::information_schema.sql_identifier AS collation_catalog, (NULL::character varying)::information_schema.sql_identifier AS collation_schema, (NULL::character varying)::information_schema.sql_identifier AS collation_name, (NULL::integer)::information_schema.cardinal_number AS numeric_precision, (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix, (NULL::integer)::information_schema.cardinal_number AS numeric_scale, (NULL::integer)::information_schema.cardinal_number AS datetime_precision, (NULL::character varying)::information_schema.character_data AS interval_type, (NULL::character varying)::information_schema.character_data AS interval_precision, (current_database())::information_schema.sql_identifier AS udt_catalog, (nt.nspname)::information_schema.sql_identifier AS udt_schema, (t.typname)::information_schema.sql_identifier AS udt_name, (NULL::character varying)::information_schema.sql_identifier AS scope_catalog, (NULL::character varying)::information_schema.sql_identifier AS scope_schema, (NULL::character varying)::information_schema.sql_identifier AS scope_name, (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality, ((ss.x).n)::information_schema.sql_identifier AS dtd_identifier FROM pg_type t, pg_namespace nt, (SELECT n.nspname AS n_nspname, p.proname, p.oid AS p_oid, p.proargnames, p.proargmodes, information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x FROM pg_namespace n, pg_proc p WHERE ((n.oid = p.pronamespace) AND (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text)))) ss WHERE ((t.oid = (ss.x).x) AND (t.typnamespace = nt.oid));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_all_tables	SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, pg_stat_get_numscans(c.oid) AS seq_scan, pg_stat_get_tuples_returned(c.oid) AS seq_tup_read, (sum(pg_stat_get_numscans(i.indexrelid)))::bigint AS idx_scan, ((sum(pg_stat_get_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_tuples_fetched(c.oid)) AS idx_tup_fetch, pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins, pg_stat_get_tuples_updated(c.oid) AS n_tup_upd, pg_stat_get_tuples_deleted(c.oid) AS n_tup_del, pg_stat_get_tuples_hot_updated(c.oid) AS n_tup_hot_upd, pg_stat_get_live_tuples(c.oid) AS n_live_tup, pg_stat_get_dead_tuples(c.oid) AS n_dead_tup, pg_stat_get_last_vacuum_time(c.oid) AS last_vacuum, pg_stat_get_last_autovacuum_time(c.oid) AS last_autovacuum, pg_stat_get_last_analyze_time(c.oid) AS last_analyze, pg_stat_get_last_autoanalyze_time(c.oid) AS last_autoanalyze FROM ((pg_class c LEFT JOIN pg_index i ON ((c.oid = i.indrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"])) GROUP BY c.oid, n.nspname, c.relname;	NONE	NO	NO
car_shop_db	information_schema	referential_constraints	SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (ncon.nspname)::information_schema.sql_identifier AS constraint_schema, (con.conname)::information_schema.sql_identifier AS constraint_name, (CASE WHEN (npkc.nspname IS NULL) THEN NULL::name ELSE current_database() END)::information_schema.sql_identifier AS unique_constraint_catalog, (npkc.nspname)::information_schema.sql_identifier AS unique_constraint_schema, (pkc.conname)::information_schema.sql_identifier AS unique_constraint_name, (CASE con.confmatchtype WHEN 'f'::"char" THEN 'FULL'::text WHEN 'p'::"char" THEN 'PARTIAL'::text WHEN 'u'::"char" THEN 'NONE'::text ELSE NULL::text END)::information_schema.character_data AS match_option, (CASE con.confupdtype WHEN 'c'::"char" THEN 'CASCADE'::text WHEN 'n'::"char" THEN 'SET NULL'::text WHEN 'd'::"char" THEN 'SET DEFAULT'::text WHEN 'r'::"char" THEN 'RESTRICT'::text WHEN 'a'::"char" THEN 'NO ACTION'::text ELSE NULL::text END)::information_schema.character_data AS update_rule, (CASE con.confdeltype WHEN 'c'::"char" THEN 'CASCADE'::text WHEN 'n'::"char" THEN 'SET NULL'::text WHEN 'd'::"char" THEN 'SET DEFAULT'::text WHEN 'r'::"char" THEN 'RESTRICT'::text WHEN 'a'::"char" THEN 'NO ACTION'::text ELSE NULL::text END)::information_schema.character_data AS delete_rule FROM ((((((pg_namespace ncon JOIN pg_constraint con ON ((ncon.oid = con.connamespace))) JOIN pg_class c ON (((con.conrelid = c.oid) AND (con.contype = 'f'::"char")))) LEFT JOIN pg_depend d1 ON (((((d1.objid = con.oid) AND (d1.classid = ('pg_constraint'::regclass)::oid)) AND (d1.refclassid = ('pg_class'::regclass)::oid)) AND (d1.refobjsubid = 0)))) LEFT JOIN pg_depend d2 ON ((((((d2.refclassid = ('pg_constraint'::regclass)::oid) AND (d2.classid = ('pg_class'::regclass)::oid)) AND (d2.objid = d1.refobjid)) AND (d2.objsubid = 0)) AND (d2.deptype = 'i'::"char")))) LEFT JOIN pg_constraint pkc ON ((((pkc.oid = d2.refobjid) AND (pkc.contype = ANY (ARRAY['p'::"char", 'u'::"char"]))) AND (pkc.conrelid = con.confrelid)))) LEFT JOIN pg_namespace npkc ON ((pkc.connamespace = npkc.oid))) WHERE ((pg_has_role(c.relowner, 'USAGE'::text) OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)) OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_sys_tables	SELECT pg_stat_all_tables.relid, pg_stat_all_tables.schemaname, pg_stat_all_tables.relname, pg_stat_all_tables.seq_scan, pg_stat_all_tables.seq_tup_read, pg_stat_all_tables.idx_scan, pg_stat_all_tables.idx_tup_fetch, pg_stat_all_tables.n_tup_ins, pg_stat_all_tables.n_tup_upd, pg_stat_all_tables.n_tup_del, pg_stat_all_tables.n_tup_hot_upd, pg_stat_all_tables.n_live_tup, pg_stat_all_tables.n_dead_tup, pg_stat_all_tables.last_vacuum, pg_stat_all_tables.last_autovacuum, pg_stat_all_tables.last_analyze, pg_stat_all_tables.last_autoanalyze FROM pg_stat_all_tables WHERE ((pg_stat_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_tables.schemaname ~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	information_schema	role_column_grants	SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (g_grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (a.attname)::information_schema.sql_identifier AS column_name, (pr.type)::information_schema.character_data AS privilege_type, (CASE WHEN ((pg_has_role(g_grantee.oid, c.relowner, 'USAGE'::text) OR aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, true))) OR aclcontains(a.attacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_attribute a, pg_class c, pg_namespace nc, pg_authid u_grantor, pg_authid g_grantee, (VALUES ('SELECT'::text), ('INSERT'::text), ('UPDATE'::text), ('REFERENCES'::text)) pr(type) WHERE (((((((a.attrelid = c.oid) AND (c.relnamespace = nc.oid)) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND (aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, false)) OR aclcontains(a.attacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, false)))) AND ((u_grantor.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR (g_grantee.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles))));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_user_tables	SELECT pg_stat_all_tables.relid, pg_stat_all_tables.schemaname, pg_stat_all_tables.relname, pg_stat_all_tables.seq_scan, pg_stat_all_tables.seq_tup_read, pg_stat_all_tables.idx_scan, pg_stat_all_tables.idx_tup_fetch, pg_stat_all_tables.n_tup_ins, pg_stat_all_tables.n_tup_upd, pg_stat_all_tables.n_tup_del, pg_stat_all_tables.n_tup_hot_upd, pg_stat_all_tables.n_live_tup, pg_stat_all_tables.n_dead_tup, pg_stat_all_tables.last_vacuum, pg_stat_all_tables.last_autovacuum, pg_stat_all_tables.last_analyze, pg_stat_all_tables.last_autoanalyze FROM pg_stat_all_tables WHERE ((pg_stat_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_tables.schemaname !~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	information_schema	role_routine_grants	SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (g_grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS specific_catalog, (n.nspname)::information_schema.sql_identifier AS specific_schema, ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name, (current_database())::information_schema.sql_identifier AS routine_catalog, (n.nspname)::information_schema.sql_identifier AS routine_schema, (p.proname)::information_schema.sql_identifier AS routine_name, ('EXECUTE'::character varying)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(g_grantee.oid, p.proowner, 'USAGE'::text) OR aclcontains(p.proacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'EXECUTE'::text, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_proc p, pg_namespace n, pg_authid u_grantor, pg_authid g_grantee WHERE (((p.pronamespace = n.oid) AND aclcontains(p.proacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'EXECUTE'::text, false))) AND ((u_grantor.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR (g_grantee.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles))));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_all_tables	SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read, pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit, (sum((pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))))::bigint AS idx_blks_read, (sum(pg_stat_get_blocks_hit(i.indexrelid)))::bigint AS idx_blks_hit, (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read, pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit, (pg_stat_get_blocks_fetched(x.oid) - pg_stat_get_blocks_hit(x.oid)) AS tidx_blks_read, pg_stat_get_blocks_hit(x.oid) AS tidx_blks_hit FROM ((((pg_class c LEFT JOIN pg_index i ON ((c.oid = i.indrelid))) LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid))) LEFT JOIN pg_class x ON ((t.reltoastidxid = x.oid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"])) GROUP BY c.oid, n.nspname, c.relname, t.oid, x.oid;	NONE	NO	NO
car_shop_db	information_schema	role_table_grants	SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (g_grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (pr.type)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(g_grantee.oid, c.relowner, 'USAGE'::text) OR aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable, ('NO'::character varying)::information_schema.character_data AS with_hierarchy FROM pg_class c, pg_namespace nc, pg_authid u_grantor, pg_authid g_grantee, (VALUES ('SELECT'::text), ('INSERT'::text), ('UPDATE'::text), ('DELETE'::text), ('TRUNCATE'::text), ('REFERENCES'::text), ('TRIGGER'::text)) pr(type) WHERE ((((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, false))) AND ((u_grantor.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR (g_grantee.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles))));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_sys_tables	SELECT pg_statio_all_tables.relid, pg_statio_all_tables.schemaname, pg_statio_all_tables.relname, pg_statio_all_tables.heap_blks_read, pg_statio_all_tables.heap_blks_hit, pg_statio_all_tables.idx_blks_read, pg_statio_all_tables.idx_blks_hit, pg_statio_all_tables.toast_blks_read, pg_statio_all_tables.toast_blks_hit, pg_statio_all_tables.tidx_blks_read, pg_statio_all_tables.tidx_blks_hit FROM pg_statio_all_tables WHERE ((pg_statio_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_tables.schemaname ~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	information_schema	role_usage_grants	SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (g_grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS object_catalog, (''::character varying)::information_schema.sql_identifier AS object_schema, (fdw.fdwname)::information_schema.sql_identifier AS object_name, ('FOREIGN DATA WRAPPER'::character varying)::information_schema.character_data AS object_type, ('USAGE'::character varying)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(g_grantee.oid, fdw.fdwowner, 'USAGE'::text) OR aclcontains(fdw.fdwacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE'::text, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_foreign_data_wrapper fdw, pg_authid u_grantor, pg_authid g_grantee WHERE (aclcontains(fdw.fdwacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE'::text, false)) AND ((u_grantor.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR (g_grantee.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)))) UNION ALL SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (g_grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS object_catalog, (''::character varying)::information_schema.sql_identifier AS object_schema, (srv.srvname)::information_schema.sql_identifier AS object_name, ('FOREIGN SERVER'::character varying)::information_schema.character_data AS object_type, ('USAGE'::character varying)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(g_grantee.oid, srv.srvowner, 'USAGE'::text) OR aclcontains(srv.srvacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE'::text, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_foreign_server srv, pg_authid u_grantor, pg_authid g_grantee WHERE (aclcontains(srv.srvacl, makeaclitem(g_grantee.oid, u_grantor.oid, 'USAGE'::text, false)) AND ((u_grantor.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles)) OR (g_grantee.rolname IN (SELECT enabled_roles.role_name FROM information_schema.enabled_roles))));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_user_tables	SELECT pg_statio_all_tables.relid, pg_statio_all_tables.schemaname, pg_statio_all_tables.relname, pg_statio_all_tables.heap_blks_read, pg_statio_all_tables.heap_blks_hit, pg_statio_all_tables.idx_blks_read, pg_statio_all_tables.idx_blks_hit, pg_statio_all_tables.toast_blks_read, pg_statio_all_tables.toast_blks_hit, pg_statio_all_tables.tidx_blks_read, pg_statio_all_tables.tidx_blks_hit FROM pg_statio_all_tables WHERE ((pg_statio_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_tables.schemaname !~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_all_indexes	SELECT c.oid AS relid, i.oid AS indexrelid, n.nspname AS schemaname, c.relname, i.relname AS indexrelname, pg_stat_get_numscans(i.oid) AS idx_scan, pg_stat_get_tuples_returned(i.oid) AS idx_tup_read, pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch FROM (((pg_class c JOIN pg_index x ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"]));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_sys_indexes	SELECT pg_stat_all_indexes.relid, pg_stat_all_indexes.indexrelid, pg_stat_all_indexes.schemaname, pg_stat_all_indexes.relname, pg_stat_all_indexes.indexrelname, pg_stat_all_indexes.idx_scan, pg_stat_all_indexes.idx_tup_read, pg_stat_all_indexes.idx_tup_fetch FROM pg_stat_all_indexes WHERE ((pg_stat_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_indexes.schemaname ~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_user_indexes	SELECT pg_statio_all_indexes.relid, pg_statio_all_indexes.indexrelid, pg_statio_all_indexes.schemaname, pg_statio_all_indexes.relname, pg_statio_all_indexes.indexrelname, pg_statio_all_indexes.idx_blks_read, pg_statio_all_indexes.idx_blks_hit FROM pg_statio_all_indexes WHERE ((pg_statio_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_indexes.schemaname !~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	information_schema	routine_privileges	SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS specific_catalog, (n.nspname)::information_schema.sql_identifier AS specific_schema, ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name, (current_database())::information_schema.sql_identifier AS routine_catalog, (n.nspname)::information_schema.sql_identifier AS routine_schema, (p.proname)::information_schema.sql_identifier AS routine_name, ('EXECUTE'::character varying)::information_schema.character_data AS privilege_type, (CASE WHEN (pg_has_role(grantee.oid, p.proowner, 'USAGE'::text) OR aclcontains(p.proacl, makeaclitem(grantee.oid, u_grantor.oid, 'EXECUTE'::text, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_proc p, pg_namespace n, pg_authid u_grantor, (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid UNION ALL SELECT (0)::oid AS oid, 'PUBLIC') grantee(oid, rolname) WHERE (((p.pronamespace = n.oid) AND aclcontains(p.proacl, makeaclitem(grantee.oid, u_grantor.oid, 'EXECUTE'::text, false))) AND ((pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text)) OR (grantee.rolname = 'PUBLIC'::name)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_all_sequences	SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read, pg_stat_get_blocks_hit(c.oid) AS blks_hit FROM (pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'S'::"char");	NONE	NO	NO
car_shop_db	information_schema	column_udt_usage	SELECT (current_database())::information_schema.sql_identifier AS udt_catalog, (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier AS udt_schema, (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier AS udt_name, (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (a.attname)::information_schema.sql_identifier AS column_name FROM pg_attribute a, pg_class c, pg_namespace nc, ((pg_type t JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) LEFT JOIN (pg_type bt JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid)))) WHERE (((((((a.attrelid = c.oid) AND (a.atttypid = t.oid)) AND (nc.oid = c.relnamespace)) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_sys_sequences	SELECT pg_statio_all_sequences.relid, pg_statio_all_sequences.schemaname, pg_statio_all_sequences.relname, pg_statio_all_sequences.blks_read, pg_statio_all_sequences.blks_hit FROM pg_statio_all_sequences WHERE ((pg_statio_all_sequences.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_sequences.schemaname ~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	information_schema	routines	SELECT (current_database())::information_schema.sql_identifier AS specific_catalog, (n.nspname)::information_schema.sql_identifier AS specific_schema, ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name, (current_database())::information_schema.sql_identifier AS routine_catalog, (n.nspname)::information_schema.sql_identifier AS routine_schema, (p.proname)::information_schema.sql_identifier AS routine_name, ('FUNCTION'::character varying)::information_schema.character_data AS routine_type, (NULL::character varying)::information_schema.sql_identifier AS module_catalog, (NULL::character varying)::information_schema.sql_identifier AS module_schema, (NULL::character varying)::information_schema.sql_identifier AS module_name, (NULL::character varying)::information_schema.sql_identifier AS udt_catalog, (NULL::character varying)::information_schema.sql_identifier AS udt_schema, (NULL::character varying)::information_schema.sql_identifier AS udt_name, (CASE WHEN ((t.typelem <> (0)::oid) AND (t.typlen = (-1))) THEN 'ARRAY'::text WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer) ELSE 'USER-DEFINED'::text END)::information_schema.character_data AS data_type, (NULL::integer)::information_schema.cardinal_number AS character_maximum_length, (NULL::integer)::information_schema.cardinal_number AS character_octet_length, (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS character_set_schema, (NULL::character varying)::information_schema.sql_identifier AS character_set_name, (NULL::character varying)::information_schema.sql_identifier AS collation_catalog, (NULL::character varying)::information_schema.sql_identifier AS collation_schema, (NULL::character varying)::information_schema.sql_identifier AS collation_name, (NULL::integer)::information_schema.cardinal_number AS numeric_precision, (NULL::integer)::information_schema.cardinal_number AS numeric_precision_radix, (NULL::integer)::information_schema.cardinal_number AS numeric_scale, (NULL::integer)::information_schema.cardinal_number AS datetime_precision, (NULL::character varying)::information_schema.character_data AS interval_type, (NULL::character varying)::information_schema.character_data AS interval_precision, (current_database())::information_schema.sql_identifier AS type_udt_catalog, (nt.nspname)::information_schema.sql_identifier AS type_udt_schema, (t.typname)::information_schema.sql_identifier AS type_udt_name, (NULL::character varying)::information_schema.sql_identifier AS scope_catalog, (NULL::character varying)::information_schema.sql_identifier AS scope_schema, (NULL::character varying)::information_schema.sql_identifier AS scope_name, (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality, (0)::information_schema.sql_identifier AS dtd_identifier, (CASE WHEN (l.lanname = 'sql'::name) THEN 'SQL'::text ELSE 'EXTERNAL'::text END)::information_schema.character_data AS routine_body, (CASE WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc ELSE NULL::text END)::information_schema.character_data AS routine_definition, (CASE WHEN (l.lanname = 'c'::name) THEN p.prosrc ELSE NULL::text END)::information_schema.character_data AS external_name, (upper((l.lanname)::text))::information_schema.character_data AS external_language, ('GENERAL'::character varying)::information_schema.character_data AS parameter_style, (CASE WHEN (p.provolatile = 'i'::"char") THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_deterministic, ('MODIFIES'::character varying)::information_schema.character_data AS sql_data_access, (CASE WHEN p.proisstrict THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_null_call, (NULL::character varying)::information_schema.character_data AS sql_path, ('YES'::character varying)::information_schema.character_data AS schema_level_routine, (0)::information_schema.cardinal_number AS max_dynamic_result_sets, (NULL::character varying)::information_schema.character_data AS is_user_defined_cast, (NULL::character varying)::information_schema.character_data AS is_implicitly_invocable, (CASE WHEN p.prosecdef THEN 'DEFINER'::text ELSE 'INVOKER'::text END)::information_schema.character_data AS security_type, (NULL::character varying)::information_schema.sql_identifier AS to_sql_specific_catalog, (NULL::character varying)::information_schema.sql_identifier AS to_sql_specific_schema, (NULL::character varying)::information_schema.sql_identifier AS to_sql_specific_name, ('NO'::character varying)::information_schema.character_data AS as_locator, (NULL::timestamp with time zone)::information_schema.time_stamp AS created, (NULL::timestamp with time zone)::information_schema.time_stamp AS last_altered, (NULL::character varying)::information_schema.character_data AS new_savepoint_level, ('YES'::character varying)::information_schema.character_data AS is_udt_dependent, (NULL::character varying)::information_schema.character_data AS result_cast_from_data_type, (NULL::character varying)::information_schema.character_data AS result_cast_as_locator, (NULL::integer)::information_schema.cardinal_number AS result_cast_char_max_length, (NULL::integer)::information_schema.cardinal_number AS result_cast_char_octet_length, (NULL::character varying)::information_schema.sql_identifier AS result_cast_char_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS result_cast_char_set_schema, (NULL::character varying)::information_schema.sql_identifier AS result_cast_character_set_name, (NULL::character varying)::information_schema.sql_identifier AS result_cast_collation_catalog, (NULL::character varying)::information_schema.sql_identifier AS result_cast_collation_schema, (NULL::character varying)::information_schema.sql_identifier AS result_cast_collation_name, (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_precision, (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_precision_radix, (NULL::integer)::information_schema.cardinal_number AS result_cast_numeric_scale, (NULL::integer)::information_schema.cardinal_number AS result_cast_datetime_precision, (NULL::character varying)::information_schema.character_data AS result_cast_interval_type, (NULL::character varying)::information_schema.character_data AS result_cast_interval_precision, (NULL::character varying)::information_schema.sql_identifier AS result_cast_type_udt_catalog, (NULL::character varying)::information_schema.sql_identifier AS result_cast_type_udt_schema, (NULL::character varying)::information_schema.sql_identifier AS result_cast_type_udt_name, (NULL::character varying)::information_schema.sql_identifier AS result_cast_scope_catalog, (NULL::character varying)::information_schema.sql_identifier AS result_cast_scope_schema, (NULL::character varying)::information_schema.sql_identifier AS result_cast_scope_name, (NULL::integer)::information_schema.cardinal_number AS result_cast_maximum_cardinality, (NULL::character varying)::information_schema.sql_identifier AS result_cast_dtd_identifier FROM pg_namespace n, pg_proc p, pg_language l, pg_type t, pg_namespace nt WHERE (((((n.oid = p.pronamespace) AND (p.prolang = l.oid)) AND (p.prorettype = t.oid)) AND (t.typnamespace = nt.oid)) AND (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_user_sequences	SELECT pg_statio_all_sequences.relid, pg_statio_all_sequences.schemaname, pg_statio_all_sequences.relname, pg_statio_all_sequences.blks_read, pg_statio_all_sequences.blks_hit FROM pg_statio_all_sequences WHERE ((pg_statio_all_sequences.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_sequences.schemaname !~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	information_schema	schemata	SELECT (current_database())::information_schema.sql_identifier AS catalog_name, (n.nspname)::information_schema.sql_identifier AS schema_name, (u.rolname)::information_schema.sql_identifier AS schema_owner, (NULL::character varying)::information_schema.sql_identifier AS default_character_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS default_character_set_schema, (NULL::character varying)::information_schema.sql_identifier AS default_character_set_name, (NULL::character varying)::information_schema.character_data AS sql_path FROM pg_namespace n, pg_authid u WHERE ((n.nspowner = u.oid) AND pg_has_role(n.nspowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_activity	SELECT s.datid, d.datname, s.procpid, s.usesysid, u.rolname AS usename, s.current_query, s.waiting, s.xact_start, s.query_start, s.backend_start, s.client_addr, s.client_port FROM pg_database d, pg_stat_get_activity(NULL::integer) s(datid, procpid, usesysid, current_query, waiting, xact_start, query_start, backend_start, client_addr, client_port), pg_authid u WHERE ((s.datid = d.oid) AND (s.usesysid = u.oid));	NONE	NO	NO
car_shop_db	information_schema	columns	SELECT (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (a.attname)::information_schema.sql_identifier AS column_name, (a.attnum)::information_schema.cardinal_number AS ordinal_position, (pg_get_expr(ad.adbin, ad.adrelid))::information_schema.character_data AS column_default, (CASE WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text ELSE 'YES'::text END)::information_schema.character_data AS is_nullable, (CASE WHEN (t.typtype = 'd'::"char") THEN CASE WHEN ((bt.typelem <> (0)::oid) AND (bt.typlen = (-1))) THEN 'ARRAY'::text WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer) ELSE 'USER-DEFINED'::text END ELSE CASE WHEN ((t.typelem <> (0)::oid) AND (t.typlen = (-1))) THEN 'ARRAY'::text WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer) ELSE 'USER-DEFINED'::text END END)::information_schema.character_data AS data_type, (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_maximum_length, (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_octet_length, (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision, (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix, (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_scale, (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS datetime_precision, (NULL::character varying)::information_schema.character_data AS interval_type, (NULL::character varying)::information_schema.character_data AS interval_precision, (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS character_set_schema, (NULL::character varying)::information_schema.sql_identifier AS character_set_name, (NULL::character varying)::information_schema.sql_identifier AS collation_catalog, (NULL::character varying)::information_schema.sql_identifier AS collation_schema, (NULL::character varying)::information_schema.sql_identifier AS collation_name, (CASE WHEN (t.typtype = 'd'::"char") THEN current_database() ELSE NULL::name END)::information_schema.sql_identifier AS domain_catalog, (CASE WHEN (t.typtype = 'd'::"char") THEN nt.nspname ELSE NULL::name END)::information_schema.sql_identifier AS domain_schema, (CASE WHEN (t.typtype = 'd'::"char") THEN t.typname ELSE NULL::name END)::information_schema.sql_identifier AS domain_name, (current_database())::information_schema.sql_identifier AS udt_catalog, (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier AS udt_schema, (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier AS udt_name, (NULL::character varying)::information_schema.sql_identifier AS scope_catalog, (NULL::character varying)::information_schema.sql_identifier AS scope_schema, (NULL::character varying)::information_schema.sql_identifier AS scope_name, (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality, (a.attnum)::information_schema.sql_identifier AS dtd_identifier, ('NO'::character varying)::information_schema.character_data AS is_self_referencing, ('NO'::character varying)::information_schema.character_data AS is_identity, (NULL::character varying)::information_schema.character_data AS identity_generation, (NULL::character varying)::information_schema.character_data AS identity_start, (NULL::character varying)::information_schema.character_data AS identity_increment, (NULL::character varying)::information_schema.character_data AS identity_maximum, (NULL::character varying)::information_schema.character_data AS identity_minimum, (NULL::character varying)::information_schema.character_data AS identity_cycle, ('NEVER'::character varying)::information_schema.character_data AS is_generated, (NULL::character varying)::information_schema.character_data AS generation_expression, (CASE WHEN ((c.relkind = 'r'::"char") OR (((c.relkind = 'v'::"char") AND (EXISTS (SELECT 1 FROM pg_rewrite WHERE (((pg_rewrite.ev_class = c.oid) AND (pg_rewrite.ev_type = '2'::"char")) AND pg_rewrite.is_instead)))) AND (EXISTS (SELECT 1 FROM pg_rewrite WHERE (((pg_rewrite.ev_class = c.oid) AND (pg_rewrite.ev_type = '4'::"char")) AND pg_rewrite.is_instead))))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_updatable FROM (pg_attribute a LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum)))), pg_class c, pg_namespace nc, ((pg_type t JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) LEFT JOIN (pg_type bt JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid)))) WHERE ((((((((a.attrelid = c.oid) AND (a.atttypid = t.oid)) AND (nc.oid = c.relnamespace)) AND (NOT pg_is_other_temp_schema(nc.oid))) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_database	SELECT d.oid AS datid, d.datname, pg_stat_get_db_numbackends(d.oid) AS numbackends, pg_stat_get_db_xact_commit(d.oid) AS xact_commit, pg_stat_get_db_xact_rollback(d.oid) AS xact_rollback, (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read, pg_stat_get_db_blocks_hit(d.oid) AS blks_hit, pg_stat_get_db_tuples_returned(d.oid) AS tup_returned, pg_stat_get_db_tuples_fetched(d.oid) AS tup_fetched, pg_stat_get_db_tuples_inserted(d.oid) AS tup_inserted, pg_stat_get_db_tuples_updated(d.oid) AS tup_updated, pg_stat_get_db_tuples_deleted(d.oid) AS tup_deleted FROM pg_database d;	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_user_functions	SELECT p.oid AS funcid, n.nspname AS schemaname, p.proname AS funcname, pg_stat_get_function_calls(p.oid) AS calls, (pg_stat_get_function_time(p.oid) / 1000) AS total_time, (pg_stat_get_function_self_time(p.oid) / 1000) AS self_time FROM (pg_proc p LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace))) WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_bgwriter	SELECT pg_stat_get_bgwriter_timed_checkpoints() AS checkpoints_timed, pg_stat_get_bgwriter_requested_checkpoints() AS checkpoints_req, pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint, pg_stat_get_bgwriter_buf_written_clean() AS buffers_clean, pg_stat_get_bgwriter_maxwritten_clean() AS maxwritten_clean, pg_stat_get_buf_written_backend() AS buffers_backend, pg_stat_get_buf_alloc() AS buffers_alloc;	NONE	NO	NO
car_shop_db	information_schema	constraint_column_usage	SELECT (current_database())::information_schema.sql_identifier AS table_catalog, (x.tblschema)::information_schema.sql_identifier AS table_schema, (x.tblname)::information_schema.sql_identifier AS table_name, (x.colname)::information_schema.sql_identifier AS column_name, (current_database())::information_schema.sql_identifier AS constraint_catalog, (x.cstrschema)::information_schema.sql_identifier AS constraint_schema, (x.cstrname)::information_schema.sql_identifier AS constraint_name FROM (SELECT DISTINCT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname FROM pg_namespace nr, pg_class r, pg_attribute a, pg_depend d, pg_namespace nc, pg_constraint c WHERE (((((((((((nr.oid = r.relnamespace) AND (r.oid = a.attrelid)) AND (d.refclassid = ('pg_class'::regclass)::oid)) AND (d.refobjid = r.oid)) AND (d.refobjsubid = a.attnum)) AND (d.classid = ('pg_constraint'::regclass)::oid)) AND (d.objid = c.oid)) AND (c.connamespace = nc.oid)) AND (c.contype = 'c'::"char")) AND (r.relkind = 'r'::"char")) AND (NOT a.attisdropped)) UNION ALL SELECT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname FROM pg_namespace nr, pg_class r, pg_attribute a, pg_namespace nc, pg_constraint c WHERE (((((((nr.oid = r.relnamespace) AND (r.oid = a.attrelid)) AND (nc.oid = c.connamespace)) AND CASE WHEN (c.contype = 'f'::"char") THEN ((r.oid = c.confrelid) AND (a.attnum = ANY (c.confkey))) ELSE ((r.oid = c.conrelid) AND (a.attnum = ANY (c.conkey))) END) AND (NOT a.attisdropped)) AND (c.contype = ANY (ARRAY['p'::"char", 'u'::"char", 'f'::"char"]))) AND (r.relkind = 'r'::"char"))) x(tblschema, tblname, tblowner, colname, cstrschema, cstrname) WHERE pg_has_role(x.tblowner, 'USAGE'::text);	NONE	NO	NO
car_shop_db	pg_catalog	pg_user_mappings	SELECT u.oid AS umid, s.oid AS srvid, s.srvname, u.umuser, CASE WHEN (u.umuser = (0)::oid) THEN 'public'::name ELSE a.rolname END AS usename, CASE WHEN (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)) THEN u.umoptions ELSE NULL::text[] END AS umoptions FROM ((pg_user_mapping u LEFT JOIN pg_authid a ON ((a.oid = u.umuser))) JOIN pg_foreign_server s ON ((u.umserver = s.oid)));	NONE	NO	NO
car_shop_db	information_schema	column_privileges	SELECT (u_grantor.rolname)::information_schema.sql_identifier AS grantor, (grantee.rolname)::information_schema.sql_identifier AS grantee, (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (a.attname)::information_schema.sql_identifier AS column_name, (pr.type)::information_schema.character_data AS privilege_type, (CASE WHEN ((pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR aclcontains(c.relacl, makeaclitem(grantee.oid, u_grantor.oid, pr.type, true))) OR aclcontains(a.attacl, makeaclitem(grantee.oid, u_grantor.oid, pr.type, true))) THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM pg_attribute a, pg_class c, pg_namespace nc, pg_authid u_grantor, (SELECT pg_authid.oid, pg_authid.rolname FROM pg_authid UNION ALL SELECT (0)::oid AS oid, 'PUBLIC') grantee(oid, rolname), (VALUES ('SELECT'::text), ('INSERT'::text), ('UPDATE'::text), ('REFERENCES'::text)) pr(type) WHERE (((((((a.attrelid = c.oid) AND (c.relnamespace = nc.oid)) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND (aclcontains(c.relacl, makeaclitem(grantee.oid, u_grantor.oid, pr.type, false)) OR aclcontains(a.attacl, makeaclitem(grantee.oid, u_grantor.oid, pr.type, false)))) AND ((pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text)) OR (grantee.rolname = 'PUBLIC'::name)));	NONE	NO	NO
car_shop_db	pg_catalog	pg_stat_user_indexes	SELECT pg_stat_all_indexes.relid, pg_stat_all_indexes.indexrelid, pg_stat_all_indexes.schemaname, pg_stat_all_indexes.relname, pg_stat_all_indexes.indexrelname, pg_stat_all_indexes.idx_scan, pg_stat_all_indexes.idx_tup_read, pg_stat_all_indexes.idx_tup_fetch FROM pg_stat_all_indexes WHERE ((pg_stat_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_indexes.schemaname !~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_all_indexes	SELECT c.oid AS relid, i.oid AS indexrelid, n.nspname AS schemaname, c.relname, i.relname AS indexrelname, (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read, pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit FROM (((pg_class c JOIN pg_index x ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"]));	NONE	NO	NO
car_shop_db	pg_catalog	pg_statio_sys_indexes	SELECT pg_statio_all_indexes.relid, pg_statio_all_indexes.indexrelid, pg_statio_all_indexes.schemaname, pg_statio_all_indexes.relname, pg_statio_all_indexes.indexrelname, pg_statio_all_indexes.idx_blks_read, pg_statio_all_indexes.idx_blks_hit FROM pg_statio_all_indexes WHERE ((pg_statio_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_indexes.schemaname ~ '^pg_toast'::text));	NONE	NO	NO
car_shop_db	information_schema	information_schema_catalog_name	SELECT (current_database())::information_schema.sql_identifier AS catalog_name;	NONE	NO	NO
car_shop_db	information_schema	applicable_roles	SELECT (a.rolname)::information_schema.sql_identifier AS grantee, (b.rolname)::information_schema.sql_identifier AS role_name, (CASE WHEN m.admin_option THEN 'YES'::text ELSE 'NO'::text END)::information_schema.character_data AS is_grantable FROM ((pg_auth_members m JOIN pg_authid a ON ((m.member = a.oid))) JOIN pg_authid b ON ((m.roleid = b.oid))) WHERE pg_has_role(a.oid, 'USAGE'::text);	NONE	NO	NO
car_shop_db	information_schema	administrable_role_authorizations	SELECT applicable_roles.grantee, applicable_roles.role_name, applicable_roles.is_grantable FROM information_schema.applicable_roles WHERE ((applicable_roles.is_grantable)::text = 'YES'::text);	NONE	NO	NO
car_shop_db	information_schema	attributes	SELECT (current_database())::information_schema.sql_identifier AS udt_catalog, (nc.nspname)::information_schema.sql_identifier AS udt_schema, (c.relname)::information_schema.sql_identifier AS udt_name, (a.attname)::information_schema.sql_identifier AS attribute_name, (a.attnum)::information_schema.cardinal_number AS ordinal_position, (pg_get_expr(ad.adbin, ad.adrelid))::information_schema.character_data AS attribute_default, (CASE WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text ELSE 'YES'::text END)::information_schema.character_data AS is_nullable, (CASE WHEN ((t.typelem <> (0)::oid) AND (t.typlen = (-1))) THEN 'ARRAY'::text WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer) ELSE 'USER-DEFINED'::text END)::information_schema.character_data AS data_type, (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_maximum_length, (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS character_octet_length, (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog, (NULL::character varying)::information_schema.sql_identifier AS character_set_schema, (NULL::character varying)::information_schema.sql_identifier AS character_set_name, (NULL::character varying)::information_schema.sql_identifier AS collation_catalog, (NULL::character varying)::information_schema.sql_identifier AS collation_schema, (NULL::character varying)::information_schema.sql_identifier AS collation_name, (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision, (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix, (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_scale, (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS datetime_precision, (NULL::character varying)::information_schema.character_data AS interval_type, (NULL::character varying)::information_schema.character_data AS interval_precision, (current_database())::information_schema.sql_identifier AS attribute_udt_catalog, (nt.nspname)::information_schema.sql_identifier AS attribute_udt_schema, (t.typname)::information_schema.sql_identifier AS attribute_udt_name, (NULL::character varying)::information_schema.sql_identifier AS scope_catalog, (NULL::character varying)::information_schema.sql_identifier AS scope_schema, (NULL::character varying)::information_schema.sql_identifier AS scope_name, (NULL::integer)::information_schema.cardinal_number AS maximum_cardinality, (a.attnum)::information_schema.sql_identifier AS dtd_identifier, ('NO'::character varying)::information_schema.character_data AS is_derived_reference_attribute FROM (pg_attribute a LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum)))), pg_class c, pg_namespace nc, (pg_type t JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) WHERE ((((((a.attrelid = c.oid) AND (a.atttypid = t.oid)) AND (nc.oid = c.relnamespace)) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND (c.relkind = 'c'::"char"));	NONE	NO	NO
car_shop_db	information_schema	check_constraint_routine_usage	SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (nc.nspname)::information_schema.sql_identifier AS constraint_schema, (c.conname)::information_schema.sql_identifier AS constraint_name, (current_database())::information_schema.sql_identifier AS specific_catalog, (np.nspname)::information_schema.sql_identifier AS specific_schema, ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name FROM pg_namespace nc, pg_constraint c, pg_depend d, pg_proc p, pg_namespace np WHERE ((((((((nc.oid = c.connamespace) AND (c.contype = 'c'::"char")) AND (c.oid = d.objid)) AND (d.classid = ('pg_constraint'::regclass)::oid)) AND (d.refobjid = p.oid)) AND (d.refclassid = ('pg_proc'::regclass)::oid)) AND (p.pronamespace = np.oid)) AND pg_has_role(p.proowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	information_schema	check_constraints	SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (rs.nspname)::information_schema.sql_identifier AS constraint_schema, (con.conname)::information_schema.sql_identifier AS constraint_name, ("substring"(pg_get_constraintdef(con.oid), 7))::information_schema.character_data AS check_clause FROM (((pg_constraint con LEFT JOIN pg_namespace rs ON ((rs.oid = con.connamespace))) LEFT JOIN pg_class c ON ((c.oid = con.conrelid))) LEFT JOIN pg_type t ON ((t.oid = con.contypid))) WHERE (pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE'::text) AND (con.contype = 'c'::"char")) UNION SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog, (n.nspname)::information_schema.sql_identifier AS constraint_schema, (((((((n.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) || '_not_null'::text))::information_schema.sql_identifier AS constraint_name, (((a.attname)::text || ' IS NOT NULL'::text))::information_schema.character_data AS check_clause FROM pg_namespace n, pg_class r, pg_attribute a WHERE (((((((n.oid = r.relnamespace) AND (r.oid = a.attrelid)) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND a.attnotnull) AND (r.relkind = 'r'::"char")) AND pg_has_role(r.relowner, 'USAGE'::text));	NONE	NO	NO
car_shop_db	information_schema	column_domain_usage	SELECT (current_database())::information_schema.sql_identifier AS domain_catalog, (nt.nspname)::information_schema.sql_identifier AS domain_schema, (t.typname)::information_schema.sql_identifier AS domain_name, (current_database())::information_schema.sql_identifier AS table_catalog, (nc.nspname)::information_schema.sql_identifier AS table_schema, (c.relname)::information_schema.sql_identifier AS table_name, (a.attname)::information_schema.sql_identifier AS column_name FROM pg_type t, pg_namespace nt, pg_class c, pg_namespace nc, pg_attribute a WHERE (((((((((t.typnamespace = nt.oid) AND (c.relnamespace = nc.oid)) AND (a.attrelid = c.oid)) AND (a.atttypid = t.oid)) AND (t.typtype = 'd'::"char")) AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"]))) AND (a.attnum > 0)) AND (NOT a.attisdropped)) AND pg_has_role(t.typowner, 'USAGE'::text));	NONE	NO	NO
